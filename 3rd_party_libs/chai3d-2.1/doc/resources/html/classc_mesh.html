<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CHAI3D: cMesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cMesh Class Reference<br/>
<small>
[<a class="el" href="group__scenegraph.html">Scenegraph</a>]</small>
</h1><!-- doxytag: class="cMesh" --><!-- doxytag: inherits="cGenericObject" -->
<p><a class="el" href="classc_mesh.html" title="cMesh represents a collection of vertices, triangles, materials, and texture properties...">cMesh</a> represents a collection of vertices, triangles, materials, and texture properties that can be rendered graphically and haptically.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_c_mesh_8h_source.html">CMesh.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cMesh:</div>
<div class="dynsection">
<div class="center"><img src="classc_mesh__inherit__graph.png" border="0" usemap="#c_mesh_inherit__map" alt="Inheritance graph"/></div>
<map name="c_mesh_inherit__map" id="c_mesh_inherit__map">
<area shape="rect" href="classc_g_e_l_mesh.html" title="cGELMesh inherits from cMesh and integrate a skeleton model for deformation simulation..." alt="" coords="19,237,104,267"/><area shape="rect" href="classc_generic_object.html" title="This class is the root of basically every render&#45;able object in CHAI. It defines..." alt="" coords="5,83,117,112"/><area shape="rect" href="classc_generic_type.html" title="Definition of an abstract type." alt="" coords="11,5,112,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classc_mesh-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a9bff5b601f51ff9a6953ee88265399a0">cMesh</a> (<a class="el" href="classc_world.html">cWorld</a> *a_world)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor of <a class="el" href="classc_mesh.html" title="cMesh represents a collection of vertices, triangles, materials, and texture properties...">cMesh</a>.  <a href="#a9bff5b601f51ff9a6953ee88265399a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3148f48c2bb9a7d5c2626f03bfa1586f"></a><!-- doxytag: member="cMesh::~cMesh" ref="a3148f48c2bb9a7d5c2626f03bfa1586f" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a3148f48c2bb9a7d5c2626f03bfa1586f">~cMesh</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor of <a class="el" href="classc_mesh.html" title="cMesh represents a collection of vertices, triangles, materials, and texture properties...">cMesh</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a342c9a482e4ed3e8d4bcc20ad33be470"></a><!-- doxytag: member="cMesh::getParentWorld" ref="a342c9a482e4ed3e8d4bcc20ad33be470" args="() const " -->
<a class="el" href="classc_world.html">cWorld</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a342c9a482e4ed3e8d4bcc20ad33be470">getParentWorld</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get parent world. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc8ef70b49d4a264aa16c0cdec7f40d9"></a><!-- doxytag: member="cMesh::setParentWorld" ref="adc8ef70b49d4a264aa16c0cdec7f40d9" args="(cWorld *a_world)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#adc8ef70b49d4a264aa16c0cdec7f40d9">setParentWorld</a> (<a class="el" href="classc_world.html">cWorld</a> *a_world)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set parent world. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#aa63902e30998ee5afbcf803f4a402fa1">loadFromFile</a> (const string &amp;a_fileName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a 3D object file (CHAI currently supports .obj and .3ds files).  <a href="#aa63902e30998ee5afbcf803f4a402fa1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a63737ed7cde2a661d61491a1d86f546b">newVertex</a> (const double a_x, const double a_y, const double a_z)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new vertex and add it to the vertex list.  <a href="#a63737ed7cde2a661d61491a1d86f546b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56d8667d4c8083bf83dfda9b4cbd7438"></a><!-- doxytag: member="cMesh::newVertex" ref="a56d8667d4c8083bf83dfda9b4cbd7438" args="(const cVector3d &amp;a_pos)" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a56d8667d4c8083bf83dfda9b4cbd7438">newVertex</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_pos)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new vertex and add it to the vertex list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a337b5dae8de0b891d40df5307e94c5fc">addVertices</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> *a_vertexPositions, const unsigned int &amp;a_numVertices)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an array of vertices to the vertex list given an array of vertex positions.  <a href="#a337b5dae8de0b891d40df5307e94c5fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#ac22c0f25dfad0332384fe6b113e0a775">removeVertex</a> (const unsigned int a_index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the vertex at the specified position in my vertex array.  <a href="#ac22c0f25dfad0332384fe6b113e0a775"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classc_vertex.html">cVertex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a66187308185f62542e5e8e4b4ef7cecf">getVertex</a> (unsigned int a_index, bool a_includeChildren=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the vertex at the specified position in my vertex array (and maybe my childrens' arrays).  <a href="#a66187308185f62542e5e8e4b4ef7cecf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a140684b2ee40456563fc7a008aa12e3f"></a><!-- doxytag: member="cMesh::getVertex" ref="a140684b2ee40456563fc7a008aa12e3f" args="(unsigned int a_index, bool a_includeChildren=false) const " -->
const <a class="el" href="classc_vertex.html">cVertex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a140684b2ee40456563fc7a008aa12e3f">getVertex</a> (unsigned int a_index, bool a_includeChildren=false) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the vertex at the specified position in my vertex array (and maybe my childrens' arrays). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a60cf1b199b7864f000495ad3ad403eeb">getNumVertices</a> (bool a_includeChildren=false) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the number of stored vertices, optionally including those of my children.  <a href="#a60cf1b199b7864f000495ad3ad403eeb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af886ca109d4372523d740a6a94cdbea3"></a><!-- doxytag: member="cMesh::pVertices" ref="af886ca109d4372523d740a6a94cdbea3" args="()" -->
virtual vector&lt; <a class="el" href="classc_vertex.html">cVertex</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#af886ca109d4372523d740a6a94cdbea3">pVertices</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access my vertex list directly (use carefully). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97c3765ba93d885530cb3dcb321a77b6"></a><!-- doxytag: member="cMesh::pVertices" ref="a97c3765ba93d885530cb3dcb321a77b6" args="() const " -->
virtual const vector&lt; <a class="el" href="classc_vertex.html">cVertex</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a97c3765ba93d885530cb3dcb321a77b6">pVertices</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access my vertex list directly (use carefully). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual vector&lt; <a class="el" href="classc_vertex.html">cVertex</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a43d44b7c69d2567ee11cb67f6aeff82a">pVerticesNonEmpty</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the first non-empty vertex list in any of my children (use carefully).  <a href="#a43d44b7c69d2567ee11cb67f6aeff82a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a58352953e8110dfd532100d19a1e6913">newTriangle</a> (const unsigned int a_indexVertex0, const unsigned int a_indexVertex1, const unsigned int a_indexVertex2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new triangle by passing vertex indices.  <a href="#a58352953e8110dfd532100d19a1e6913"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#af0cedec2099c237bf4642f32b0e0161d">newTriangle</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_vertex0, const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_vertex1, const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_vertex2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new triangle and three new vertices by passing vertex positions.  <a href="#af0cedec2099c237bf4642f32b0e0161d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a97b1ea0e9137e5740a1be9e8d465f63f">removeTriangle</a> (const unsigned int a_index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a triangle from my triangle array.  <a href="#a97b1ea0e9137e5740a1be9e8d465f63f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classc_triangle.html">cTriangle</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#ad3fb3454ffdd5a406284bbff69511c08">getTriangle</a> (unsigned int a_index, bool a_includeChildren=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the triangle at the specified position in my triangle array.  <a href="#ad3fb3454ffdd5a406284bbff69511c08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a8f8015aa58b8841d5ac9c00219c3460f">getNumTriangles</a> (bool a_includeChildren=false) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the number of stored triangles, optionally including those of my children.  <a href="#a8f8015aa58b8841d5ac9c00219c3460f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a242a359193af1b33cf5c96bc86e08679">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear all triangles and vertices of mesh.  <a href="#a242a359193af1b33cf5c96bc86e08679"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af48ea4c83e9b5cff44db5261b96190fb"></a><!-- doxytag: member="cMesh::pTriangles" ref="af48ea4c83e9b5cff44db5261b96190fb" args="()" -->
vector&lt; <a class="el" href="classc_triangle.html">cTriangle</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#af48ea4c83e9b5cff44db5261b96190fb">pTriangles</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access my triangle array directly (use carefully). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a6f1b5d31fc08c0e4a1fce2e1c01c40c6">setTransparencyLevel</a> (const float a_level, const bool a_applyToTextures=false, const bool a_affectChildren=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the alpha value at each vertex and in all of my material colors.  <a href="#a6f1b5d31fc08c0e4a1fce2e1c01c40c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a3f0606b66ee54c8aacc21c81d80e1b29">setVertexColor</a> (const <a class="el" href="structc_colorf.html">cColorf</a> &amp;a_color, const bool a_affectChildren=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set color of each vertex, optionally propagating the operation to my children.  <a href="#a3f0606b66ee54c8aacc21c81d80e1b29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a75eedbf31c88d7ab5700bb31cfff32ea">useDisplayList</a> (const bool a_useDisplayList, const bool a_affectChildren=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disable the use of a display list for rendering, optionally propagating the operation to my children.  <a href="#a75eedbf31c88d7ab5700bb31cfff32ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#aaed1d811d15e11d6c352cfa4a49bdfbf">useVertexArrays</a> (const bool a_useVertexArrays, const bool a_affectChildren=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disable the use vertex arrays for rendering, optionally propagating the operation to my children.  <a href="#aaed1d811d15e11d6c352cfa4a49bdfbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae10033855c3032c932132a9f8cdab83c"></a><!-- doxytag: member="cMesh::getDisplayListEnabled" ref="ae10033855c3032c932132a9f8cdab83c" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#ae10033855c3032c932132a9f8cdab83c">getDisplayListEnabled</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ask whether I'm currently rendering with a display list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a3a441d795b3ce0a021df6fe8d4cbde41">invalidateDisplayList</a> (const bool a_affectChildren=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invalidate any existing display lists.  <a href="#a3a441d795b3ce0a021df6fe8d4cbde41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#ae7f710ab3fc9417af839c5e1cec65b2d">setShowNormals</a> (const bool &amp;a_showNormals, const bool a_affectChildren=true, const bool a_trianglesOnly=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disable the rendering of vertex normals, optionally propagating the operation to my children.  <a href="#ae7f710ab3fc9417af839c5e1cec65b2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a420aeb674d40d94e668e00ed9e6fc2d1"></a><!-- doxytag: member="cMesh::getShowNormals" ref="a420aeb674d40d94e668e00ed9e6fc2d1" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a420aeb674d40d94e668e00ed9e6fc2d1">getShowNormals</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether rendering of normals is enabled. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a795ffe398866f4b3c267272aaf511b15">setNormalsProperties</a> (const double a_length, const <a class="el" href="structc_colorf.html">cColorf</a> &amp;a_color, const bool a_affectChildren)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set graphic properties for normal-rendering, optionally propagating the operation to my children.  <a href="#a795ffe398866f4b3c267272aaf511b15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4af777d3130c2ae6dde6257f65c6e3d"></a><!-- doxytag: member="cMesh::getColorsEnabled" ref="ae4af777d3130c2ae6dde6257f65c6e3d" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#ae4af777d3130c2ae6dde6257f65c6e3d">getColorsEnabled</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Are vertex colors currently enabled? <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a7fc10e529990bc678f026a9f7d1607e2">onDisplayReset</a> (const bool a_affectChildren=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Re-initializes textures and display lists.  <a href="#a7fc10e529990bc678f026a9f7d1607e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a561e6712db6a8be028913dcfc1decc86">createBruteForceCollisionDetector</a> (bool a_affectChildren, bool a_useNeighbors)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up a brute force collision detector for this mesh and (optionally) for its children.  <a href="#a561e6712db6a8be028913dcfc1decc86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#ad06d723c9504c59f8437d1ec9adf5c10">createAABBCollisionDetector</a> (double a_radius, bool a_affectChildren, bool a_useNeighbors)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up an AABB collision detector for this mesh and (optionally) its children.  <a href="#ad06d723c9504c59f8437d1ec9adf5c10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a570ff5d63f1e7fcf9834003d69da2607">createSphereTreeCollisionDetector</a> (double a_radius, bool a_affectChildren, bool a_useNeighbors)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up a sphere tree collision detector for this mesh and (optionally) its children.  <a href="#a570ff5d63f1e7fcf9834003d69da2607"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#af47774acc3d23cadab06ece6b8a58929">createTriangleNeighborList</a> (bool a_affectChildren)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a lists for neighbor triangles for each triangle of the mesh.  <a href="#af47774acc3d23cadab06ece6b8a58929"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a013a23fbe40dcb0c98289a95552c6f18">findNeighbors</a> (std::vector&lt; <a class="el" href="classc_triangle.html">cTriangle</a> * &gt; *search1, std::vector&lt; <a class="el" href="classc_triangle.html">cTriangle</a> * &gt; *search2, const int &amp;v1, const int &amp;v2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for triangle neighbors.  <a href="#a013a23fbe40dcb0c98289a95552c6f18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a9e0b0ee81e5417c0b14cc5e80a693193">computeLocalInteraction</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_toolPos, const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_toolVel, const unsigned int a_IDN)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the relationship between the tool and the current object.  <a href="#a9e0b0ee81e5417c0b14cc5e80a693193"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a14bee05dea46ba15e4e71cb03a64c830">computeAllNormals</a> (const bool a_affectChildren=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute all triangle normals, optionally propagating the operation to my children.  <a href="#a14bee05dea46ba15e4e71cb03a64c830"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#ac62cd6dac15209cbe14eb455484a785f">extrude</a> (const double a_extrudeDistance, const bool a_affectChildren=false, const bool a_updateCollisionDetector=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extrude each vertex of the mesh by some amount along its normal.  <a href="#ac62cd6dac15209cbe14eb455484a785f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#ac257d5534e5847f3e9b4fae8ebcb0371">offsetVertices</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_offset, const bool a_affectChildren=false, const bool a_updateCollisionDetector=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a4d019b75790f2a3ae8c266c5e40a54f8">scaleObject</a> (const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;a_scaleFactors)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scale vertices and normals by the specified scale factors and re-normalize.  <a href="#a4d019b75790f2a3ae8c266c5e40a54f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae29fcb5cafad340f76c0552b5d59d6f0"></a><!-- doxytag: member="cMesh::createMesh" ref="ae29fcb5cafad340f76c0552b5d59d6f0" args="() const " -->
virtual <a class="el" href="classc_mesh.html">cMesh</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#ae29fcb5cafad340f76c0552b5d59d6f0">createMesh</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple method used to create a new (empty) mesh of my type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a89f39eda46b815b96a3def30c536eeb0">renderMesh</a> (const int a_renderMode=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render triangles, material and texture properties.  <a href="#a89f39eda46b815b96a3def30c536eeb0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structc_vector3d.html">cVector3d</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a87d3ff4c297df41564eab853dcd74d6f">getCenterOfMass</a> (const bool a_includeChildren=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the center of mass of this mesh, based on vertex positions.  <a href="#a87d3ff4c297df41564eab853dcd74d6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a40c0d1e18be22989775416a19af3bcad">reverseAllNormals</a> (const bool a_affectChildren=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverse all normals on this model.  <a href="#a40c0d1e18be22989775416a19af3bcad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a079dbedbb5b34f5a6233a29e2045167f">removeRedundantTriangles</a> (const bool a_affectChildren=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove redundant triangles from this model.  <a href="#a079dbedbb5b34f5a6233a29e2045167f"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#add34043a0d263f2353c79985c9ca4098">render</a> (const int a_renderMode=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render the mesh itself.  <a href="#add34043a0d263f2353c79985c9ca4098"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#ac0fa7954e047b23752cc45abd3df2a6a">renderNormals</a> (const bool a_trianglesOnly=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw a small line for each vertex normal.  <a href="#ac0fa7954e047b23752cc45abd3df2a6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a3ede84c6660fe8bc998635fe62372071">updateGlobalPositions</a> (const bool a_frameOnly)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the global position of each of my vertices.  <a href="#a3ede84c6660fe8bc998635fe62372071"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#af30caff0fb81775565baaeaf7be29e6d">updateBoundaryBox</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update my boundary box dimensions based on my vertices.  <a href="#af30caff0fb81775565baaeaf7be29e6d"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a2c3643c055f2e8fd0d1a7c699dfa98"></a><!-- doxytag: member="cMesh::m_parentWorld" ref="a1a2c3643c055f2e8fd0d1a7c699dfa98" args="" -->
<a class="el" href="classc_world.html">cWorld</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a1a2c3643c055f2e8fd0d1a7c699dfa98">m_parentWorld</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parent world. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7743ad9be254547bc9cb4190570f6b25"></a><!-- doxytag: member="cMesh::m_showNormals" ref="a7743ad9be254547bc9cb4190570f6b25" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a7743ad9be254547bc9cb4190570f6b25">m_showNormals</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <b>true</b>, then normals are displayed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c49cbf0006f1983dde7d13b89501f7d"></a><!-- doxytag: member="cMesh::m_showNormalsForTriangleVerticesOnly" ref="a0c49cbf0006f1983dde7d13b89501f7d" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a0c49cbf0006f1983dde7d13b89501f7d">m_showNormalsForTriangleVerticesOnly</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If <b>true</b>, normals are displayed only for vertices that are used in triangles. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdc14a0648ed340b49061fb69b0d77fc"></a><!-- doxytag: member="cMesh::m_showNormalsColor" ref="abdc14a0648ed340b49061fb69b0d77fc" args="" -->
<a class="el" href="structc_colorf.html">cColorf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#abdc14a0648ed340b49061fb69b0d77fc">m_showNormalsColor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Color used to render lines representing normals. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93829a6503a8a61787b49254340d94b2"></a><!-- doxytag: member="cMesh::m_showNormalsLength" ref="a93829a6503a8a61787b49254340d94b2" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a93829a6503a8a61787b49254340d94b2">m_showNormalsLength</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Length of each normal (for graphic rendering of normals). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd63b10aed5116d7fb2c5e1da4616a2a"></a><!-- doxytag: member="cMesh::m_useDisplayList" ref="abd63b10aed5116d7fb2c5e1da4616a2a" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#abd63b10aed5116d7fb2c5e1da4616a2a">m_useDisplayList</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Should we use a display list to render this mesh? <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc2750657631e2c8917f3700f4939bee"></a><!-- doxytag: member="cMesh::m_useVertexArrays" ref="abc2750657631e2c8917f3700f4939bee" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#abc2750657631e2c8917f3700f4939bee">m_useVertexArrays</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Should we use vertex arrays to render this mesh? <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb0b3f2ef0e76ae4063204f2972228b9"></a><!-- doxytag: member="cMesh::m_displayList" ref="afb0b3f2ef0e76ae4063204f2972228b9" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#afb0b3f2ef0e76ae4063204f2972228b9">m_displayList</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The openGL display list used to draw this mesh, if display lists are enabled. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefeb839b97ef3e48e40957a65ff3bda6"></a><!-- doxytag: member="cMesh::m_vertices" ref="aefeb839b97ef3e48e40957a65ff3bda6" args="" -->
vector&lt; <a class="el" href="classc_vertex.html">cVertex</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#aefeb839b97ef3e48e40957a65ff3bda6">m_vertices</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of vertices. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea91fb22ee4bf8265b52e3c18da19d46"></a><!-- doxytag: member="cMesh::m_freeVertices" ref="aea91fb22ee4bf8265b52e3c18da19d46" args="" -->
list&lt; unsigned int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#aea91fb22ee4bf8265b52e3c18da19d46">m_freeVertices</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of free slots in the vertex array. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae513b5d9fa25d575bd6f1209fe0c7742"></a><!-- doxytag: member="cMesh::m_triangles" ref="ae513b5d9fa25d575bd6f1209fe0c7742" args="" -->
vector&lt; <a class="el" href="classc_triangle.html">cTriangle</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#ae513b5d9fa25d575bd6f1209fe0c7742">m_triangles</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of triangles. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2db1b7d64f9b5978f009f698672c2e07"></a><!-- doxytag: member="cMesh::m_freeTriangles" ref="a2db1b7d64f9b5978f009f698672c2e07" args="" -->
list&lt; unsigned int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc_mesh.html#a2db1b7d64f9b5978f009f698672c2e07">m_freeTriangles</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of free slots in the triangle array. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="classc_mesh.html" title="cMesh represents a collection of vertices, triangles, materials, and texture properties...">cMesh</a> represents a collection of vertices, triangles, materials, and texture properties that can be rendered graphically and haptically. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9bff5b601f51ff9a6953ee88265399a0"></a><!-- doxytag: member="cMesh::cMesh" ref="a9bff5b601f51ff9a6953ee88265399a0" args="(cWorld *a_world)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cMesh::cMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classc_world.html">cWorld</a> *&nbsp;</td>
          <td class="paramname"> <em>a_world</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor of <a class="el" href="classc_mesh.html" title="cMesh represents a collection of vertices, triangles, materials, and texture properties...">cMesh</a>. </p>
<p>Constructor of <a class="el" href="classc_mesh.html" title="cMesh represents a collection of vertices, triangles, materials, and texture properties...">cMesh</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_world</em>&nbsp;</td><td>Pointer to parent world. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a337b5dae8de0b891d40df5307e94c5fc"></a><!-- doxytag: member="cMesh::addVertices" ref="a337b5dae8de0b891d40df5307e94c5fc" args="(const cVector3d *a_vertexPositions, const unsigned int &amp;a_numVertices)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::addVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> *&nbsp;</td>
          <td class="paramname"> <em>a_vertexPositions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&nbsp;</td>
          <td class="paramname"> <em>a_numVertices</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an array of vertices to the vertex list given an array of vertex positions. </p>
<p>Create a new vertex for each supplied position and add it to the vertex list.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_vertexPositions</em>&nbsp;</td><td>List of vertex positions to add </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_numVertices</em>&nbsp;</td><td>Number of vertices in a_vertexPositions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a242a359193af1b33cf5c96bc86e08679"></a><!-- doxytag: member="cMesh::clear" ref="a242a359193af1b33cf5c96bc86e08679" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear all triangles and vertices of mesh. </p>
<p>Clear all triangles and vertices. </p>

</div>
</div>
<a class="anchor" id="a14bee05dea46ba15e4e71cb03a64c830"></a><!-- doxytag: member="cMesh::computeAllNormals" ref="a14bee05dea46ba15e4e71cb03a64c830" args="(const bool a_affectChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::computeAllNormals </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute all triangle normals, optionally propagating the operation to my children. </p>
<p>Compute surface normals for every vertex in the mesh, by averaging the face normals of the triangle that include each vertex.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, then children are also updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e0b0ee81e5417c0b14cc5e80a693193"></a><!-- doxytag: member="cMesh::computeLocalInteraction" ref="a9e0b0ee81e5417c0b14cc5e80a693193" args="(const cVector3d &amp;a_toolPos, const cVector3d &amp;a_toolVel, const unsigned int a_IDN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::computeLocalInteraction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_toolPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_toolVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>a_IDN</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update the relationship between the tool and the current object. </p>
<p>For mesh objects, this information is computed by the virtual tool when computing the finger-proxy model. More information can be found in file CGeneric3dofPointer.cpp undr methof computeInteractionForces() Both variables m_interactionProjectedPoint and m_interactionInside are assigned values based on the objects encountered by the proxy.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_toolPos</em>&nbsp;</td><td>Position of the tool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_toolVel</em>&nbsp;</td><td>Velocity of the tool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_IDN</em>&nbsp;</td><td>Identification number of the force algorithm. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classc_generic_object.html#af80fcd6a2dd14d167b82b7cbda9a43dd">cGenericObject</a>.</p>

</div>
</div>
<a class="anchor" id="ad06d723c9504c59f8437d1ec9adf5c10"></a><!-- doxytag: member="cMesh::createAABBCollisionDetector" ref="ad06d723c9504c59f8437d1ec9adf5c10" args="(double a_radius, bool a_affectChildren, bool a_useNeighbors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::createAABBCollisionDetector </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>a_useNeighbors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up an AABB collision detector for this mesh and (optionally) its children. </p>
<p>Set up an AABB collision detector for this mesh and (optionally) its children</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_radius</em>&nbsp;</td><td>Bounding radius. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>Create collision detectors for children? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_useNeighbors</em>&nbsp;</td><td>Create neighbor lists? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a561e6712db6a8be028913dcfc1decc86"></a><!-- doxytag: member="cMesh::createBruteForceCollisionDetector" ref="a561e6712db6a8be028913dcfc1decc86" args="(bool a_affectChildren, bool a_useNeighbors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::createBruteForceCollisionDetector </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>a_useNeighbors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up a brute force collision detector for this mesh and (optionally) for its children. </p>
<p>Set up a Brute Force collision detector for this mesh and (optionally) its children</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>Create collision detectors for children? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_useNeighbors</em>&nbsp;</td><td>Create neighbor lists? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a570ff5d63f1e7fcf9834003d69da2607"></a><!-- doxytag: member="cMesh::createSphereTreeCollisionDetector" ref="a570ff5d63f1e7fcf9834003d69da2607" args="(double a_radius, bool a_affectChildren, bool a_useNeighbors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::createSphereTreeCollisionDetector </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>a_useNeighbors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up a sphere tree collision detector for this mesh and (optionally) its children. </p>
<p>Set up a sphere tree collision detector for this mesh and (optionally) its children</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_radius</em>&nbsp;</td><td>Bounding radius. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>Create collision detectors for children? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_useNeighbors</em>&nbsp;</td><td>Create neighbor lists? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af47774acc3d23cadab06ece6b8a58929"></a><!-- doxytag: member="cMesh::createTriangleNeighborList" ref="af47774acc3d23cadab06ece6b8a58929" args="(bool a_affectChildren)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::createTriangleNeighborList </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a lists for neighbor triangles for each triangle of the mesh. </p>
<p>Set up for each triangle a list of neighbor triangles</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>Create neighborlists for children? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac62cd6dac15209cbe14eb455484a785f"></a><!-- doxytag: member="cMesh::extrude" ref="ac62cd6dac15209cbe14eb455484a785f" args="(const double a_extrudeDistance, const bool a_affectChildren=false, const bool a_updateCollisionDetector=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::extrude </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>a_extrudeDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_updateCollisionDetector</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extrude each vertex of the mesh by some amount along its normal. </p>
<p>Extrude each vertex of the mesh by some amount along its normal</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_extrudeDistance</em>&nbsp;</td><td>Distance to move each vertex </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, children are also modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_updateCollisionDetector</em>&nbsp;</td><td>If <b>true</b>, this mesh's collision detector is re-initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a013a23fbe40dcb0c98289a95552c6f18"></a><!-- doxytag: member="cMesh::findNeighbors" ref="a013a23fbe40dcb0c98289a95552c6f18" args="(std::vector&lt; cTriangle * &gt; *search1, std::vector&lt; cTriangle * &gt; *search2, const int &amp;v1, const int &amp;v2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::findNeighbors </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classc_triangle.html">cTriangle</a> * &gt; *&nbsp;</td>
          <td class="paramname"> <em>search1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classc_triangle.html">cTriangle</a> * &gt; *&nbsp;</td>
          <td class="paramname"> <em>search2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>v2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search for triangle neighbors. </p>
<p>Find pairs of neighboring triangles that share specific vertices, given vectors of those triangles sorted by the x-coordinates of those vertices (first, second, or third), using a merge join. We define two triangles to be neighbors if and only if they have a common vertex (within some distance tolerance). In this function, we are only concerned about matching triangles whose vertex v1 in search1 is shared (within tolerance) with vertex v2 in search2; this function should be called once for each possible combination (order doesn't matter) of v1=0..2 and v2=0..2 to find all neighbors. Two shared vertices must have equal x-coordinates (within tolerance), which allows us to check for matches using a merge join on lists sorted by x-coordinate. (Using y-coordinates or z-coordinates would have been equally valid.)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>search1</em>&nbsp;</td><td>First vector of triangles, sorted by x-coords of some vertex. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>search2</em>&nbsp;</td><td>Second vector of triangles, sorted by x-coords of some vertex. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v1</em>&nbsp;</td><td>Which vertex the first vector is sorted by (0, 1, or 2). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v2</em>&nbsp;</td><td>Which vertex the second vector is sorted by (0, 1, or 2). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87d3ff4c297df41564eab853dcd74d6f"></a><!-- doxytag: member="cMesh::getCenterOfMass" ref="a87d3ff4c297df41564eab853dcd74d6f" args="(const bool a_includeChildren=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structc_vector3d.html">cVector3d</a> cMesh::getCenterOfMass </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_includeChildren</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the center of mass of this mesh, based on vertex positions. </p>
<p>Compute the center of mass of this mesh, based on vertex positions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_includeChildren</em>&nbsp;</td><td>If <b>true</b>, then childrens' COM's are reflected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f8015aa58b8841d5ac9c00219c3460f"></a><!-- doxytag: member="cMesh::getNumTriangles" ref="a8f8015aa58b8841d5ac9c00219c3460f" args="(bool a_includeChildren=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cMesh::getNumTriangles </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>a_includeChildren</em> = <code>false</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the number of stored triangles, optionally including those of my children. </p>
<p>Returns the number of triangles contained in this mesh, optionally including its children.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_includeChildren</em>&nbsp;</td><td>If <b>true</b>, then children are also included. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60cf1b199b7864f000495ad3ad403eeb"></a><!-- doxytag: member="cMesh::getNumVertices" ref="a60cf1b199b7864f000495ad3ad403eeb" args="(bool a_includeChildren=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cMesh::getNumVertices </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>a_includeChildren</em> = <code>false</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the number of stored vertices, optionally including those of my children. </p>
<p>Returns the number of vertices contained in this mesh, optionally including its children.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_includeChildren</em>&nbsp;</td><td>If <b>true</b>, then children are also included. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3fb3454ffdd5a406284bbff69511c08"></a><!-- doxytag: member="cMesh::getTriangle" ref="ad3fb3454ffdd5a406284bbff69511c08" args="(unsigned int a_index, bool a_includeChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classc_triangle.html">cTriangle</a> * cMesh::getTriangle </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>a_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>a_includeChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the triangle at the specified position in my triangle array. </p>
<p>Returns the specified triangle... if a_includeChildren is false, I just index into my triangle array (no boundary checking, since this is called often).</p>
<p>If a_includeChildren is true, I start counting through my own triangle array, then each of my children... in the process, I'm going to call getNumTriangles(true) on each of my children, so this is a recursive and unbounded (though generally fast) version of this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_index</em>&nbsp;</td><td>The index of the requested triangle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_includeChildren</em>&nbsp;</td><td>If <b>true</b>, then children are also included. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66187308185f62542e5e8e4b4ef7cecf"></a><!-- doxytag: member="cMesh::getVertex" ref="a66187308185f62542e5e8e4b4ef7cecf" args="(unsigned int a_index, bool a_includeChildren=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classc_vertex.html">cVertex</a> * cMesh::getVertex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>a_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>a_includeChildren</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the vertex at the specified position in my vertex array (and maybe my childrens' arrays). </p>
<p>Returns the specified vertex... if a_includeChildren is false, I just index into my vertex array (no boundary checking, since this is called often).</p>
<p>If a_includeChildren is true, I start counting through my own vertex array, then each of my children... in the process, I'm going to call getNumVertices(true) on each of my children, so this is a recursive and unbounded (though generally fast) version of this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_index</em>&nbsp;</td><td>The index of the requested vertex </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_includeChildren</em>&nbsp;</td><td>If <b>true</b>, then children are also included. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a441d795b3ce0a021df6fe8d4cbde41"></a><!-- doxytag: member="cMesh::invalidateDisplayList" ref="a3a441d795b3ce0a021df6fe8d4cbde41" args="(const bool a_affectChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::invalidateDisplayList </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Invalidate any existing display lists. </p>
<p>Invalidate any existing display lists. You should call this on if you're using display lists and you modify mesh options, vertex positions, etc.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b> all children are updated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa63902e30998ee5afbcf803f4a402fa1"></a><!-- doxytag: member="cMesh::loadFromFile" ref="aa63902e30998ee5afbcf803f4a402fa1" args="(const string &amp;a_fileName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cMesh::loadFromFile </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>a_fileName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a 3D object file (CHAI currently supports .obj and .3ds files). </p>
<p>Load a 3D mesh file. CHAI currently supports .obj and .3ds files.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_fileName</em>&nbsp;</td><td>Filename of 3d image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return <b>true</b> is file loaded correctly. Otherwise return FALSE. </dd></dl>

</div>
</div>
<a class="anchor" id="af0cedec2099c237bf4642f32b0e0161d"></a><!-- doxytag: member="cMesh::newTriangle" ref="af0cedec2099c237bf4642f32b0e0161d" args="(const cVector3d &amp;a_vertex0, const cVector3d &amp;a_vertex1, const cVector3d &amp;a_vertex2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cMesh::newTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_vertex0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_vertex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_vertex2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new triangle and three new vertices by passing vertex positions. </p>
<p>Create a new triangle and three new vertices by passing vertex positions</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_vertex0</em>&nbsp;</td><td>Position of vertex 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_vertex1</em>&nbsp;</td><td>Position of vertex 1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_vertex2</em>&nbsp;</td><td>Position of vertex 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return index position of new triangle. </dd></dl>

</div>
</div>
<a class="anchor" id="a58352953e8110dfd532100d19a1e6913"></a><!-- doxytag: member="cMesh::newTriangle" ref="a58352953e8110dfd532100d19a1e6913" args="(const unsigned int a_indexVertex0, const unsigned int a_indexVertex1, const unsigned int a_indexVertex2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cMesh::newTriangle </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>a_indexVertex0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>a_indexVertex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>a_indexVertex2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new triangle by passing vertex indices. </p>
<p>Create a new triangle and three new vertices by passing vertex indices</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_indexVertex0</em>&nbsp;</td><td>index position of vertex 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_indexVertex1</em>&nbsp;</td><td>index position of vertex 1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_indexVertex2</em>&nbsp;</td><td>index position of vertex 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return the index of the new triangle in my triangle array </dd></dl>

</div>
</div>
<a class="anchor" id="a63737ed7cde2a661d61491a1d86f546b"></a><!-- doxytag: member="cMesh::newVertex" ref="a63737ed7cde2a661d61491a1d86f546b" args="(const double a_x, const double a_y, const double a_z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cMesh::newVertex </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>a_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>a_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>a_z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new vertex and add it to the vertex list. </p>
<p>Create a new vertex and add it to the vertex list.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_x</em>&nbsp;</td><td>X coordinate of vertex. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_y</em>&nbsp;</td><td>Y coordinate of vertex. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_z</em>&nbsp;</td><td>Z coordinate of vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return index position of new vertex. </dd></dl>

</div>
</div>
<a class="anchor" id="ac257d5534e5847f3e9b4fae8ebcb0371"></a><!-- doxytag: member="cMesh::offsetVertices" ref="ac257d5534e5847f3e9b4fae8ebcb0371" args="(const cVector3d &amp;a_offset, const bool a_affectChildren=false, const bool a_updateCollisionDetector=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::offsetVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_updateCollisionDetector</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shifts all vertex positions by the specified amount. <br/>
 Use <a class="el" href="classc_generic_object.html#a4732065b0fa9c9e7200b706fe8b23ddd" title="Set the local position of this object.">setPos()</a> if you want to move the whole mesh for rendering.</p>
<p>Shifts all vertex positions by the specified amount.</p>
<p>Use <a class="el" href="classc_generic_object.html#a4732065b0fa9c9e7200b706fe8b23ddd" title="Set the local position of this object.">setPos()</a> if you want to move the whole mesh for rendering.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_offset</em>&nbsp;</td><td>Translation to apply to each vertex </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, children are also modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_updateCollisionDetector</em>&nbsp;</td><td>If <b>true</b>, this mesh's collision detector is re-initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7fc10e529990bc678f026a9f7d1607e2"></a><!-- doxytag: member="cMesh::onDisplayReset" ref="a7fc10e529990bc678f026a9f7d1607e2" args="(const bool a_affectChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::onDisplayReset </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Re-initializes textures and display lists. </p>
<p>Users can call this function when it's necessary to re-initialize the OpenGL context; e.g. re-initialize textures and display lists. Subclasses should perform whatever re-initialization they need to do.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b> all children are updated </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classc_generic_object.html#abceaa39ca365c7092d4b3932665439d8">cGenericObject</a>.</p>

</div>
</div>
<a class="anchor" id="a43d44b7c69d2567ee11cb67f6aeff82a"></a><!-- doxytag: member="cMesh::pVerticesNonEmpty" ref="a43d44b7c69d2567ee11cb67f6aeff82a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classc_vertex.html">cVertex</a> &gt; * cMesh::pVerticesNonEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the first non-empty vertex list in any of my children (use carefully). </p>
<p>Access the first vertex list in any of my children (use carefully) </p>

</div>
</div>
<a class="anchor" id="a079dbedbb5b34f5a6233a29e2045167f"></a><!-- doxytag: member="cMesh::removeRedundantTriangles" ref="a079dbedbb5b34f5a6233a29e2045167f" args="(const bool a_affectChildren=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::removeRedundantTriangles </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove redundant triangles from this model. </p>
<p>Remove redundant triangles from this model. Does not use vertex positions at all, just removed triangles with redundant indices and obviously- degenerate triangles.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, children are also modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97b1ea0e9137e5740a1be9e8d465f63f"></a><!-- doxytag: member="cMesh::removeTriangle" ref="a97b1ea0e9137e5740a1be9e8d465f63f" args="(const unsigned int a_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cMesh::removeTriangle </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>a_index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a triangle from my triangle array. </p>
<p>Remove a vertex from the vertex array by passing its index number.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_index</em>&nbsp;</td><td>Index number of vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return <b>true</b> if operation succeeded. </dd></dl>

</div>
</div>
<a class="anchor" id="ac22c0f25dfad0332384fe6b113e0a775"></a><!-- doxytag: member="cMesh::removeVertex" ref="ac22c0f25dfad0332384fe6b113e0a775" args="(const unsigned int a_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cMesh::removeVertex </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>a_index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the vertex at the specified position in my vertex array. </p>
<p>Remove the vertex at the specified position in my vertex array</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_index</em>&nbsp;</td><td>Index number of vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return <b>true</b> if operation succeeded. </dd></dl>

</div>
</div>
<a class="anchor" id="add34043a0d263f2353c79985c9ca4098"></a><!-- doxytag: member="cMesh::render" ref="add34043a0d263f2353c79985c9ca4098" args="(const int a_renderMode=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::render </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>a_renderMode</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Render the mesh itself. </p>
<p>Render this mesh in OpenGL. This method actually just prepares some OpenGL state, and uses renderMesh to actually do the rendering.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_renderMode</em>&nbsp;</td><td>Rendering mode (see <a class="el" href="classc_generic_object.html" title="This class is the root of basically every render-able object in CHAI. It defines...">cGenericObject</a>) </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classc_generic_object.html#a7eb87a0e7dd896f081854e693e4f60d9">cGenericObject</a>.</p>

<p>Reimplemented in <a class="el" href="classc_g_e_l_mesh.html#a6f099ca6f940be66a08502cf879f17b1">cGELMesh</a>.</p>

</div>
</div>
<a class="anchor" id="a89f39eda46b815b96a3def30c536eeb0"></a><!-- doxytag: member="cMesh::renderMesh" ref="a89f39eda46b815b96a3def30c536eeb0" args="(const int a_renderMode=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::renderMesh </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>a_renderMode</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Render triangles, material and texture properties. </p>
<p>Render the mesh itself. This function is declared public to allow sharing of data among meshes, which is not possible given most implementations of 'protected'. But it should only be accessed from within <a class="el" href="classc_mesh.html#add34043a0d263f2353c79985c9ca4098" title="Render the mesh itself.">render()</a> or derived versions of <a class="el" href="classc_mesh.html#add34043a0d263f2353c79985c9ca4098" title="Render the mesh itself.">render()</a>. </p>

</div>
</div>
<a class="anchor" id="ac0fa7954e047b23752cc45abd3df2a6a"></a><!-- doxytag: member="cMesh::renderNormals" ref="ac0fa7954e047b23752cc45abd3df2a6a" args="(const bool a_trianglesOnly=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::renderNormals </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_trianglesOnly</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw a small line for each vertex normal. </p>
<p>Render a graphic representation of each normal of the mesh. </p>

</div>
</div>
<a class="anchor" id="a40c0d1e18be22989775416a19af3bcad"></a><!-- doxytag: member="cMesh::reverseAllNormals" ref="a40c0d1e18be22989775416a19af3bcad" args="(const bool a_affectChildren=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::reverseAllNormals </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverse all normals on this model. </p>
<p>Reverse the normal for every vertex on this model. Useful for models that started with inverted faces and thus gave inward-pointing normals.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, children are also modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d019b75790f2a3ae8c266c5e40a54f8"></a><!-- doxytag: member="cMesh::scaleObject" ref="a4d019b75790f2a3ae8c266c5e40a54f8" args="(const cVector3d &amp;a_scaleFactors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::scaleObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_vector3d.html">cVector3d</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_scaleFactors</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scale vertices and normals by the specified scale factors and re-normalize. </p>
<p>Resize the current mesh by scaling all my vertex positions. If you want to move vertices along their normals, use the <a class="el" href="classc_mesh.html#ac62cd6dac15209cbe14eb455484a785f" title="Extrude each vertex of the mesh by some amount along its normal.">extrude()</a> function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_scaleFactors</em>&nbsp;</td><td>x,y,z scale factors. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classc_generic_object.html#a5c647d27f4e9f308dbf5db2af56fab17">cGenericObject</a>.</p>

</div>
</div>
<a class="anchor" id="a795ffe398866f4b3c267272aaf511b15"></a><!-- doxytag: member="cMesh::setNormalsProperties" ref="a795ffe398866f4b3c267272aaf511b15" args="(const double a_length, const cColorf &amp;a_color, const bool a_affectChildren)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::setNormalsProperties </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>a_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structc_colorf.html">cColorf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set graphic properties for normal-rendering, optionally propagating the operation to my children. </p>
<p>Define the way normals are graphically rendered, optionally propagating the operation to my children</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_length</em>&nbsp;</td><td>Length of normals </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_color</em>&nbsp;</td><td>Color of normals </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, then children also modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7f710ab3fc9417af839c5e1cec65b2d"></a><!-- doxytag: member="cMesh::setShowNormals" ref="ae7f710ab3fc9417af839c5e1cec65b2d" args="(const bool &amp;a_showNormals, const bool a_affectChildren=true, const bool a_trianglesOnly=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::setShowNormals </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&nbsp;</td>
          <td class="paramname"> <em>a_showNormals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_trianglesOnly</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable or disable the rendering of vertex normals, optionally propagating the operation to my children. </p>
<p>Enable or disable the graphic rendering of normal vectors at each vertex, optionally propagating the operation to my children</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_showNormals</em>&nbsp;</td><td>If <b>true</b>, normal vectors are rendered graphically </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, then children also modified </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_trianglesOnly</em>&nbsp;</td><td>If <b>true</b>, normals are rendered only at vertices that are used in triangles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f1b5d31fc08c0e4a1fce2e1c01c40c6"></a><!-- doxytag: member="cMesh::setTransparencyLevel" ref="a6f1b5d31fc08c0e4a1fce2e1c01c40c6" args="(const float a_level, const bool a_applyToTextures=false, const bool a_affectChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::setTransparencyLevel </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>a_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_applyToTextures</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the alpha value at each vertex and in all of my material colors. </p>
<p>Set the alpha value at each vertex, in all of my material colors, optionally propagating the operation to my children.</p>
<p>Using the 'apply to textures' option causes the actual texture alpha values to be over-written in my texture, if it exists.</p>
<p>[Editor's note: the 'apply to textures' option is not currently enabled, since (a) it's a silly way to control transparency and (b) not all textures have an alpha channel.]</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_level</em>&nbsp;</td><td>Level of transparency ranging from 0.0 to 1.0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_applyToTextures</em>&nbsp;</td><td>If <b>true</b>, then apply changes to texture </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If true, then children also modified. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classc_generic_object.html#ab7c8b442fc3acc50374df2f0f678e696">cGenericObject</a>.</p>

</div>
</div>
<a class="anchor" id="a3f0606b66ee54c8aacc21c81d80e1b29"></a><!-- doxytag: member="cMesh::setVertexColor" ref="a3f0606b66ee54c8aacc21c81d80e1b29" args="(const cColorf &amp;a_color, const bool a_affectChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::setVertexColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structc_colorf.html">cColorf</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a_color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set color of each vertex, optionally propagating the operation to my children. </p>
<p>Set color of each vertex.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_color</em>&nbsp;</td><td>New color to be applied to each vertex </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, then children also modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af30caff0fb81775565baaeaf7be29e6d"></a><!-- doxytag: member="cMesh::updateBoundaryBox" ref="af30caff0fb81775565baaeaf7be29e6d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::updateBoundaryBox </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update my boundary box dimensions based on my vertices. </p>
<p>Compute the axis-aligned boundary box that encloses all triangles in this mesh </p>

<p>Reimplemented from <a class="el" href="classc_generic_object.html#a0d5fff8fb9e5b6ecff89b29efaed9ca1">cGenericObject</a>.</p>

</div>
</div>
<a class="anchor" id="a3ede84c6660fe8bc998635fe62372071"></a><!-- doxytag: member="cMesh::updateGlobalPositions" ref="a3ede84c6660fe8bc998635fe62372071" args="(const bool a_frameOnly)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::updateGlobalPositions </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_frameOnly</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update the global position of each of my vertices. </p>
<p>Compute the global position of all vertices</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_frameOnly</em>&nbsp;</td><td>If <b>false</b>, the global position of all vertices is computed, otherwise this function does nothing. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classc_generic_object.html#af0e5d7ce19ae357176f0f407626a80f8">cGenericObject</a>.</p>

</div>
</div>
<a class="anchor" id="a75eedbf31c88d7ab5700bb31cfff32ea"></a><!-- doxytag: member="cMesh::useDisplayList" ref="a75eedbf31c88d7ab5700bb31cfff32ea" args="(const bool a_useDisplayList, const bool a_affectChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::useDisplayList </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_useDisplayList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable or disable the use of a display list for rendering, optionally propagating the operation to my children. </p>
<p>This enables the use of display lists for mesh rendering. This should significantly speed up rendering for large meshes, but it means that any changes you make to any <a class="el" href="classc_mesh.html" title="cMesh represents a collection of vertices, triangles, materials, and texture properties...">cMesh</a> options or any vertex positions will not take effect until you invalidate the existing display list (by calling <a class="el" href="classc_mesh.html#a3a441d795b3ce0a021df6fe8d4cbde41" title="Invalidate any existing display lists.">invalidateDisplayList()</a>).</p>
<p>In general, if you aren't having problems with rendering performance, don't bother with this; you don't want to worry about having to invalidate display lists every time you change a tiny option.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_useDisplayList</em>&nbsp;</td><td>If <b>true</b>, this mesh will be rendered with a display list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, then children also modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaed1d811d15e11d6c352cfa4a49bdfbf"></a><!-- doxytag: member="cMesh::useVertexArrays" ref="aaed1d811d15e11d6c352cfa4a49bdfbf" args="(const bool a_useVertexArrays, const bool a_affectChildren=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cMesh::useVertexArrays </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_useVertexArrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>a_affectChildren</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable or disable the use vertex arrays for rendering, optionally propagating the operation to my children. </p>
<p>This enables the use of vertex arrays for mesh rendering. This mode can be faster than the classical approach, however crashes sometime occur on certain types of graphic cards.</p>
<p>In general, if you aren't having problems with rendering performance, don't bother with this.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a_useVertexArrays</em>&nbsp;</td><td>If <b>true</b>, this mesh will be rendered using vertex array technique </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a_affectChildren</em>&nbsp;</td><td>If <b>true</b>, then children also modified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/tmp/chai/chai3d-2.1.0/src/scenegraph/<a class="el" href="_c_mesh_8h_source.html">CMesh.h</a></li>
<li>/tmp/chai/chai3d-2.1.0/src/scenegraph/CMesh.cpp</li>
</ul>
</div>
<font size=-2><br><hr><b>CHAI3D 2.1.0 documentation</b><br>Please address any questions to <a href="mailto:support@chai3d.org">support@chai3d.org</a><br>
	(C) 2003-2010 - <a href="http://www.chai3d.org">CHAI 3D</a><br>
	All Rights Reserved.

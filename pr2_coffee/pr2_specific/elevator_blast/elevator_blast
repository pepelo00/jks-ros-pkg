#!/usr/bin/env python

import roslib
roslib.load_manifest('elevator_blast')
import rospy
import math
import tf
import yaml
from sensor_msgs.msg import *
from visualization_msgs.msg import *
from geometry_msgs.msg import *
from pr2_msgs.srv import *
from multli_map_navigation.msg import *
from kinematics_msgs.srv import *
from pr2_controllers_msgs.msg import *
from pr2_common_action_msgs.msg import *
from trajectory_msgs.msg import *
import actionlib
import cv
from std_msgs.msg import String
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError
import roslib.packages


class ElevatorControl:
    def __init__(self):
        self.scan_msg = None
        self.exit_floor = False
        self.sign_sub_image = False
        self.floor_signs = False
        self.floor = False
        self.lights = False
        self.base_scan_msg = False
        self.goal_floor = False
        self.elevator_locations = False
        self.height = 0.0
        self.counter = 0
        self.visualization_publisher = rospy.Publisher(
            "/visualization_markers", Marker)
        self.cmd_vel_publisher = rospy.Publisher(
            "/base_controller/command", Twist)
        self.listener = tf.TransformListener()
        rospy.loginfo("Wait for laser control")
        rospy.wait_for_service("/laser_tilt_controller/set_periodic_cmd")
        self.set_laser = rospy.ServiceProxy(
            "/laser_tilt_controller/set_periodic_cmd", SetPeriodicCmd)
        rospy.Subscriber("/tilt_scan", LaserScan, self.on_scan_msg)
        rospy.Subscriber("/base_scan", LaserScan, self.on_base_scan)
        self.ac_server = actionlib.SimpleActionServer(
            "elevator_blast", MultiMapNavigationTransitionAction,
            execute_cb=self.do_elevator, auto_start=False)
        rospy.loginfo("wait for IK")
        rospy.wait_for_service("pr2_right_arm_kinematics/get_ik_solver_info")
        rospy.wait_for_service("pr2_right_arm_kinematics/get_ik")
        self.query_client = rospy.ServiceProxy(
            "pr2_right_arm_kinematics/get_ik_solver_info", 
            GetKinematicSolverInfo)
        self.ik_client = rospy.ServiceProxy(
            "pr2_right_arm_kinematics/get_ik", GetPositionIK)
        self.arm = rospy.Publisher("r_arm_controller/command", JointTrajectory)
        self.gripper = actionlib.SimpleActionClient(
            "r_gripper_controller/gripper_action", Pr2GripperCommandAction)
        self.ac_server.start()
        rospy.loginfo("Wait for tuck arm")
        self.tuck = actionlib.SimpleActionClient("tuck_arms", TuckArmsAction)
        self.tuck.wait_for_server()
        self.process_fb = False

        self.cv_debug = False
        self.location = False
        self.process_im = False
        self.process_head_im = False
        self.process_sign_im = False
        self.elevator_state = False
        if (self.cv_debug):
            cv.NamedWindow("Open CV Image", 0)
        self.bridge = CvBridge()
        self.image_sub = rospy.Subscriber(
            "/r_forearm_cam/image_rect_color", Image, self.image_callback)
        self.head_image_sub = rospy.Subscriber(
            "/wide_stereo/right/image_rect", Image, self.head_image_callback)
        
        self.head_client = actionlib.SimpleActionClient(
            '/head_traj_controller/point_head_action', PointHeadAction)
        self.head_client.wait_for_server()
        
        self.image_dir = roslib.packages.get_pkg_dir(
            'elevator_blast') + "/images/"

        rospy.loginfo("started")


    def point_head(self, x, y, z, wait=True):
        g = PointHeadGoal()
        g.target.header.frame_id = 'base_link'
        g.target.point.x = x
        g.target.point.y = y
        g.target.point.z = z
        g.min_duration = rospy.Duration(1.0)
        self.head_client.send_goal(g)
        #self.head_client.wait_for_result()
        if (wait):
            rospy.sleep(1.0)


    def cube(self, f, x, y, z, sx, sy, sz, i):
        marker = Marker()
        marker.header.frame_id = f
        marker.header.stamp = rospy.get_rostime()
        marker.ns = "elevator_blast"
        marker.type = Marker.CUBE
        marker.action = Marker.ADD
        marker.id = i
        marker.pose.position.x = x
        marker.pose.position.y = y
        marker.pose.position.z = z
        marker.pose.orientation.x = 1.0
        marker.pose.orientation.y = 0.0
        marker.pose.orientation.z = 0.0
        marker.pose.orientation.w = 1.0
        marker.scale.x = sx
        marker.scale.y = sy
        marker.scale.z = sz
        marker.color.a = 1.0
        marker.color.r = 0.0
        marker.color.g = 0.0
        marker.color.b = 1.0
        self.visualization_publisher.publish(marker)

    def mec_line_up(self, x, y):
        for i in range(0, 10):
            move = Twist()
            move.linear.x = x
            move.linear.y = y
            move.angular.z = -0.5
            self.cmd_vel_publisher.publish(move)
            rospy.sleep(0.1)
        for i in range(0, 10):
            move = Twist()
            move.linear.x = x
            move.linear.y = y
            move.angular.z = 0.5
            self.cmd_vel_publisher.publish(move)
            rospy.sleep(0.1)
        for i in range(0, 3):
            move = Twist()
            move.linear.x = x
            move.linear.y = y
            move.angular.z = -0.5
            self.cmd_vel_publisher.publish(move)
            rospy.sleep(0.1)

    def do_elevator(self, msg):
        elevator_yaml = yaml.load(msg.wormhole)
        print elevator_yaml

        self.height = 0.0

        self.point_head(1.0, 0.0, 2.0)
        self.set_laser_and_wait(-0.4)
        self.tuck_arms()
        while not self.line_up(self.scan_msg) and not rospy.is_shutdown():
            self.wait_for_scan()
        
        self.set_depth(1.0)


        #From intent
        #FIXME: sanity maintenance
        left_seq = {"start": [(1.1, math.pi / 2, 0.0, "BAIL"), 
                              (1.4, 0.0, 0.0, "BAIL"), 
                              ("SQUARE_CHECK",), 
                              (0.8, 0.0, 0.0),
                              (0.8, math.pi / 2, 0.0), 
                              (0.0, 0.0, -math.pi /2), 
                              ("SWITCH", "button_hit")],
                    "button_hit": [("FD", -0.1, 0.0, 5.0), 
                                   ("LINE_UP", -0.1, 0.0),
                                   ("FD", 0.0, -0.1, 12.0),
                                   (0.6, math.pi / 2, 0.0), 
                                   ("ARM", [-math.pi / 2, 0.0, 0.0, 
                                             -3.14159 / 180.0 * 90.0, 
                                             3.14159, 0.0, 0.0]), 
                                   ("PRESS",),
                                   (0.1, -math.pi / 2, 0.0), 
                                   (0.1, math.pi / 2, 0.0),
                                   ("TUCK", False), 
                                   (1.1, 0.0, 0.0), 
                                   (0.0, 0.0, -math.pi / 2),
                                   (0.7, 0.0, 0.0),
                                   ("HEAD", 0.0, 1.0, 2.0), 
                                   ("SWITCH", "floor_loop"),],
                    "exit": [(1.2, 0.0, 0.0, "WAIT"), 
                             (1.1, math.pi / 2, 0.0, "WAIT"), 
                             (0.0, 0.0, math.pi),],
                    "floor_loop": [(0.7, 0.0, 0.0, "WAIT-TL", 30.0, "stuck"), 
                                   ("FLOOR_CHECK", "wrong_floor",), 
                                   ("SWITCH", "exit"),],
                    "wrong_floor": [(-0.7, 0.0, 0.0),
                                    ("SLEEP", 15.0), 
                                    ("SWITCH", "floor_loop"),],
                    "stuck": [(-0.4, 0.0, 0.0), 
                              (0.0, 0.0, math.pi / 2), 
                              (-0.85, 0.0, 0.0),
                              ("SWITCH", "button_hit")]}
        right_seq = {"start": [(1.1, -math.pi / 2, 0.0, "BAIL"),
                               (1.35, 0.0, 0.0, "BAIL"), 
                               ("SQUARE_CHECK",),
                               (0.8, 0.0, 0.0),
                               (0.55, -math.pi / 2, 0.0),
                               (0.0, 0.0, -math.pi / 2), 
                               ("SWITCH", "button_hit")],
                     "button_hit": [("FD", 0.1, 0.0, 5.0),
                                    ("LINE_UP", 0.1, 0.0),
                                    ("FD", 0.0, -0.1, 10.0),
                                    (0.7 * math.sqrt(2),
                                     math.pi / 2 + math.pi / 4, 0.0),
                                    ("ARM", [-math.pi / 2 - (math.pi * 3.0 / 180.0), 0.0, 0.0, 
                                              -3.14159 / 180.0 * 90.0, 
                                              3.14159, 0.0, 0.0]),
                                    (0.65, 0.0, 0.0),
                                    ("FD", 0.3, 0.0, 1.0),
                                    ("LINE_UP", 0.1, 0.0), 
                                    ("PRESS",), 
                                    (0.1, -math.pi / 2, 0.0), 
                                    (0.1, math.pi / 2, 0.0),
                                    (-0.7, 0.0, 0.0), 
                                    ("TUCK", False), 
                                    (0.0, 0.0, -math.pi / 2), 
                                    (0.7, 0.0, 0.0),
                                    ("HEAD", 0.0, 1.0, 2.0),
                                    ("SWITCH", "floor_loop"),],
                     "floor_loop": [(0.7, 0.0, 0.0, "WAIT-TL", 30.0, "stuck"), 
                                    ("FLOOR_CHECK", "wrong_floor"), 
                                    ("SWITCH", "exit"),],
                     "wrong_floor": [(-0.7, 0.0, 0.0), 
                                     ("SLEEP", 15.0),
                                     ("SWITCH", "floor_loop"),],
                     "exit": [(1.2, 0.0, 0.0, "WAIT"), 
                              (1.1, -math.pi / 2, 0.0, "WAIT"), 
                              (0.0, 0.0, math.pi),],
                     "stuck": [(-0.7, 0.0, 0.0), 
                               (0.0, 0.0, math.pi / 2), 
                               (0.6, 0.0, 0.0), 
                               ("SWITCH", "button_hit")],}

        mult = {"call-button": {"up": (0.05, 0, 0.02),
                                "down": (0.05, 0, -0.12),
                                "arm": [0.0, 0.0, 0.0, 
                                        -3.14159 / 180.0 * 50.0,
                                        3.14159, 0.0, 0.0]
                                },
                "left": {"lights": {"up": (185.0, 138.0),
                                    "down": (185.0, 180.0)},
                         "motion_seq": left_seq,
                         },
                "right": {"lights": {"up": (375.0, 130.0),
                                     "down": (375.0, 174.0)},
                          "motion_seq": right_seq,
                          },
                }
        mult_block = {"call-button": {"up": (0.05, 0, -0.02),
                                      "down": (0.05, 0, -0.06),
                                      "arm": [0.0, 0.0, 0.0, 
                                              -3.14159 / 180.0 * 50.0, 
                                              3.14159, 0.0, 0.0]
                                      },
                      "left": {"lights": {"up": (185.0, 138.0),
                                          "down": (185.0, 180.0)},
                               "motion_seq": left_seq,
                               },
                      "right": {"lights": {"up": (375.0, 130.0),
                                           "down": (375.0, 174.0)},
                                "motion_seq": right_seq,
                                },
                      }
        single_up = {"call-button": {"up": (0.1, 0, -0.1),
                                     "arm": [0.0, -3.14159 / 180.0 * 10.0, 0.0, 
                                             -3.14159 / 180.0 * 50.0, 
                                             3.14159, 0.0, 0.0]},
                     "left": {"lights": {"up": (195.0, (138.0 + 180.0) / 2.0)},
                              "motion_seq": left_seq,
                              },
                     "right": {"lights": {"up": (385.0, (130.0 + 174.0) / 2.0)},
                               "motion_seq": right_seq,
                               },
                     }
        single_down = {"call-button": {"down": (0.1, 0, -0.1),
                                       "arm": [0.0, -3.14159 / 180.0 * 10.0,
                                               0.0, -3.14159 / 180.0 * 50.0, 
                                               3.14159, 0.0, 0.0]},
                       "left": {"lights": {"down": (195.0, 
                                                    (138.0 + 180.0) / 2.0)},
                                "motion_seq": left_seq,
                                },
                       "right": {"lights": {"down": (385.0, 
                                                     (130.0 + 174.0) / 2.0)},
                                 "motion_seq": right_seq,
                                 },
                       }
        self.elevator_locations = {"B": single_up, "1": mult,
                                   "2": mult, "3": single_down, 
                                   "sub-images": {"left": (80, 180, 150, 100),
                                                  "right": (80, 180, 150, 100)
                                                  },
                                   "sign-images": {"left": {"1": "floor_1.jpg",
                                                            "2": "floor_2.jpg",
                                                            "3": "floor_3.jpg",
                                                            "B": "floor_B.jpg"},
                                                   "right": {"1": "floor_1.jpg",
                                                             "2": "floor_2.jpg",
                                                             "3": "floor_3.jpg",
                                                             "B": "floor_B.jpg"}},
                                   "floor-order": ["B", "1", "2", "3"],
                                   "floor-heights": {"B": -6.0, "1": 0.0, 
                                                     "2": 6.0, "3": 12.0}, 
                                   "floor-buttons": {
                "left": {"3": [-1.5675391915428039, -0.1615763031295083, 
                                -0.016156285133952952, -1.4376911415880722, 
                                -15.743258254855892, -1.5125801804718826, 
                                -0.0040836229237051214],
                         "2": [-1.5855299275092696, -0.043481790475689695, 
                                -0.016637349613062513, -1.5616148705323718, 
                                -15.679337223775521, -1.5005282096042947, 
                                0.010578883149858331],
                         "1": [-1.5921624568978283, 0.074358937408815759, 
                                -0.02064622027230989, -1.6765628153708929,
                                -15.679221529601621, -1.5099696452659073,
                                -0.0043446764443024755],
                         "B": [-1.5948154686532519, 0.21097973822251009, 
                                -0.026739703674365511, -1.7834036003719365, 
                                -15.679221529601621, -1.4737702237430448, 
                                -0.00564994404728969]},
                "right": {"3": [-1.1480317077164559, -0.20497349868209358,
                                 0.049749548504070207, -1.0210410342262792,
                                 -16.234784952674804, -1.0803190592824126,
                                 0.17025661991536989],
                          "2": [-1.1212528703101494, -0.10295202141812133,
                                 0.057446580169824957, -1.0906757464017562,
                                 -16.304490692450234, -1.1135163653184033,
                                 0.24557056060776805],
                          "1": [-1.1489436805073825, 0.040097993551511606,
                                 0.060332967044482544, -1.2752584034157539,
                                 -16.148939875640174, -1.1484975370784769, 
                                 0.14036599180694864],
                          "B": [-1.1249007614738566, 0.1375513449678433,
                                 0.063219353919140575, -1.3661744101646094,
                                 -16.232760304631533, -1.1854801191631319, 
                                 0.16107623777435554]}
                }}

        #From intent
        self.floor = str(elevator_yaml["locations"][msg.start]["floor"])
        self.goal_floor = str(elevator_yaml["locations"][msg.end]["floor"])
        print "From", self.floor, "to", self.goal_floor
        
        #Calculate direction - down or up
        direct = "down"
        for floor in self.elevator_locations["floor-order"]:
            if (floor == self.goal_floor):
                direct = "down"
                break
            if (floor == self.floor):
                direct = "up"
                break
        print "Going", direct
        elevator_info = self.elevator_locations[self.floor]

        #Create lights array for head perception
        lights = {}
        for i in elevator_info:
            if (i != "call-button"):
                lights[i] = elevator_info[i]["lights"]
        self.lights = lights

        
        self.extend_arm(0.0, elevator_info["call-button"]["arm"])
        self.set_depth(0.8)

        self.location = False
        self.process_im = True

        hc = 0
        while not rospy.is_shutdown() and hc < 4:
            print self.location
            tmsg = Twist()
            if (self.location == False):
                hc = 0
                tmsg.linear.y = 0.03
            elif (self.location > 0.1):
                hc = 0
                tmsg.linear.y = -0.03
            elif (self.location < -0.1):
                hc = 0
                tmsg.linear.y = 0.03
            elif (self.location < -0.04 or self.location > 0.04):
                hc = 0
                tmsg.linear.y = -self.location / 2.0
            else:
                hc = hc + 1
                print "Hit", hc
            self.cmd_vel_publisher.publish(tmsg)
            rospy.sleep(0.01)

        self.cmd_vel_publisher.publish(Twist())

        hc = 0
        pos = 0.0
        while not rospy.is_shutdown() and hc < 4:
            print self.location
            tmsg = Twist()

            if (self.location < -0.02):
                pos = pos + 0.003
                hc = 0
            elif (self.location > 0.02):
                pos = pos - 0.003
                hc = 0
            else:
                hc = hc + 1

            goal = JointTrajectory()
            goal.header.stamp = rospy.get_rostime()
            goal.joint_names = ["r_shoulder_pan_joint", 
                                "r_shoulder_lift_joint", 
                                "r_upper_arm_roll_joint",
                                "r_elbow_flex_joint", "r_forearm_roll_joint", 
                                "r_wrist_flex_joint", "r_wrist_roll_joint"]
            goal.points = [JointTrajectoryPoint()]
            goal.points[0].positions = [pos]
            for i in elevator_info["call-button"]["arm"][1:]:
                goal.points[0].positions.append(i)
            goal.points[0].velocities = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
            goal.points[0].time_from_start = rospy.Duration.from_sec(0.3)
            
            self.arm.publish(goal)
            rospy.sleep(0.3)
            print pos, self.location
        
        self.process_im = False
        
        pos = self.get_end_effector_pos()

        self.arm_move(pos[0] - 0.05, pos[1], pos[2], 1)

        self.set_gripper(0.02)

        offset = elevator_info["call-button"][direct]
        self.arm_move(pos[0] + offset[0] - 0.05, pos[1] + offset[1], 
                      pos[2] + offset[2], 1)
        self.arm_move(pos[0] + offset[0], pos[1] + offset[1], 
                      pos[2] + offset[2], 1)
        
        self.tuck_arms(False)

        self.move_to_target(self.generate_goal(pos[1], math.pi / 2), 0.0, True)

        print "Point head"
        self.point_head(1.0, 0.0, 2.0, False)

        self.elevator_state = False
        self.process_head_im = True

        time_limit = 0

        elevator = False

        print "Start"
        while not rospy.is_shutdown() and elevator == False:
            print self.elevator_state
            if (self.elevator_state):
                for i in self.elevator_state:
                    if (self.elevator_state[i] == direct):
                        elevator = i
            rospy.sleep(0.1)
            time_limit = time_limit + 1
            if (time_limit > 300):
                return self.do_elevator(msg)

        self.process_head_im = False

        seqs = elevator_info[elevator]["motion_seq"]
        seq = seqs["start"]
        backup = [self.generate_goal(0, 0), ]
        dead = False
        while len(seq) != 0 and not rospy.is_shutdown():
            step = seq[0]
            seq = seq[1:]
            if (step[0] == "FD"):
                move = Twist()
                move.linear.x = step[1]
                move.linear.y = step[2]
                number = int(step[3] * 20)
                n = step[3] / number
                for i in range(0, number):
                    self.cmd_vel_publisher.publish(move)
                    rospy.sleep(n)
            elif (step[0] == "ARM"):
                self.extend_arm(0.0, step[1])
            elif (step[0] == "PRESS"):
                g = self.goal_floor
                pos = self.elevator_locations["floor-buttons"][elevator][g]
                self.extend_arm(0.0, pos)
            elif (step[0] == "HEAD"):
                self.point_head(step[1], step[2], step[3], True)
            elif (step[0] == "TUCK"):
                self.tuck_arms(step[1])
            elif (step[0] == "SLEEP"):
                rospy.sleep(step[1])
            elif (step[0] == "FLOOR_CHECK"):
                self.floor_signs = {}
                for floor in self.elevator_locations["sign-images"][elevator]:
                    self.floor_signs[floor] = cv.LoadImage(
                        self.image_dir.rstrip("/\\") + "/" + 
                        self.elevator_locations["sign-images"][elevator][floor],
                        cv.CV_LOAD_IMAGE_GRAYSCALE)
                self.exit_floor = False
                self.sign_sub_image \
                    = self.elevator_locations["sub-images"][elevator]
                self.process_sign_im = True
                while self.exit_floor == False and not rospy.is_shutdown():
                    rospy.sleep(0.01)
                sign = self.exit_floor
                hc = 0
                delay = 0
                while hc < 10 and not rospy.is_shutdown():
                    if (sign != self.exit_floor):
                        sign = self.exit_floor
                        hc = 0
                    else:
                        hc = hc + 1
                    if (delay > 50):
                        sign = False
                        break
                    delay = delay + 1
                    rospy.sleep(0.1)
                self.process_sign_im = False
                
                print sign
                if (sign != self.goal_floor):
                    print "Wrong floor!!"
                    seq = seqs[step[1]]
            elif (step[0] == "SWITCH"):
                seq = seqs[step[1]]
            elif (step[0] == "SQUARE_CHECK"):
                self.cmd_vel_publisher.publish(Twist())
                rospy.sleep(0.5)
                self.wait_for_base_scan()
                if (self.check_square(self.base_scan_msg)):
                    print "Square"
                else:
                    dead = True
                    print "Dead square"
                    break
            elif (step[0] == "LINE_UP"):
                self.mec_line_up(step[1], step[2])
            else:
                state = False
                if (len(step) > 3):
                    state = step[3]
                timeout = 5.0
                start = rospy.get_rostime()
                if (state == "WAIT-TL"):
                    timeout = step[4]
                    state = "BAIL"
                while not self.move_to_target(self.generate_goal(step[0],
                                                                 step[1]),
                                              step[2], True, True,
                                              watch_scans=state) \
                                              and not rospy.is_shutdown():
                    if ((rospy.get_rostime() - start).to_sec() > timeout):
                        if (state == "WAIT-TL"):
                            seq = seqs[step[5]]
                            break
                        else:
                            print "Dead"
                            dead = True
                            break
                if (dead):
                    break
            backup.insert(0, self.generate_goal(0, 0))
        
        if (dead):
            self.point_head(1.0, 0.0, 0.0)
            for i in backup:
                print i
                self.move_to_target(i, math.pi, True, True, watch_scans="WAIT")
            self.move_to_target(self.generate_goal(0, 0), math.pi, True, True, watch_scans="WAIT")
            print "Stuck!"
            return self.do_elevator(msg)
    
    def head_image_callback(self, data):
        if (self.process_head_im):
            self.process_lights(data)
        if (self.process_sign_im):
            self.process_signage(data)

    def process_signage(self, data):
        try:
            bimg = self.bridge.imgmsg_to_cv(data, "mono8")
        except CvBridgeError, e:
            print e
        

        #Create temp image
        gray = cv.CreateImage(cv.GetSize(bimg), 8, 1)
        cv.Copy(bimg, gray)
        #Strip lighting
        cv.EqualizeHist(gray, gray)
        cv.Threshold(gray, gray, 30, 255, cv.CV_THRESH_BINARY_INV)

        #Binary search for line
        white_pixels = 0
        split_width = cv.GetSize(gray)[0] / 2
        split = cv.GetSize(gray)[0] / 2
        while True:
            testimg = cv.GetSubRect(gray, (split, self.sign_sub_image[1] + self.sign_sub_image[3], 
                                           cv.GetSize(gray)[0] - split, self.sign_sub_image[3]))
            white_pixels = cv.Sum(testimg)[0] / 255
            #print split, white_pixels
            split_width = split_width / 2
            if (white_pixels < 20):
                split = split - split_width
            elif (white_pixels > 100):
                split = split + split_width
            else:
                break
        


        subrect = (split + self.sign_sub_image[0], self.sign_sub_image[1],
                   self.sign_sub_image[2], self.sign_sub_image[3])

        #Get the approximate area
        gray = cv.GetSubRect(bimg, subrect) 
        

        self.counter = self.counter + 1

        print "Save", self.counter
        cv.SaveImage("/tmp/background" + str(self.counter) + ".png", bimg)
        #cv.SaveImage("/tmp/region.png", gray)

        #Strip lighting
        cv.EqualizeHist(gray, gray)

        #Convert to binary
        cv.Threshold(gray, gray, 70, 255, cv.CV_THRESH_BINARY)

        #Hunt for vertical lines 
        min_line = 0
        for i in range(0, cv.GetSize(gray)[0] - 20):
            val = cv.Sum(cv.GetSubRect(gray, (i, 0, 1, cv.GetSize(gray)[1])))[0] / 255
            if (val < 10):
                min_line = i + 10

        gray = cv.GetSubRect(gray, (min_line, 0, cv.GetSize(gray)[0] - min_line, cv.GetSize(gray)[1]))

        #Fill from the edge in to remove most bad areas
        width = cv.GetSize(gray)[0]
        height = cv.GetSize(gray)[1]
        for i in range(0, width):
            if (cv.Get2D(gray, 1, i)[0] < 10):
                cv.FloodFill(gray, (i, 1), (255,))
            if (cv.Get2D(gray, height - 2, i)[0] < 10):
                cv.FloodFill(gray, (i, height - 2), (255,))
        for i in range(0, height):
            if (cv.Get2D(gray, i, 1)[0] < 10):
                cv.FloodFill(gray, (1, i), (255,))
            if (cv.Get2D(gray, i, width - 2)[0] < 10):
                cv.FloodFill(gray, (width - 2, i), (255,))

        #Make a list of all regions of the image by size and fill seed
        backup = cv.CreateImage(cv.GetSize(gray), 8, 1)
        cv.Copy(gray, backup)
        total = cv.Sum(backup)[0] / 255
        pts = []
        for x in range(0, width):
            for y in range(0, height):
                if (cv.Get2D(backup, y, x)[0] < 10):
                    cv.FloodFill(backup, (x, y), (255,))
                    next = cv.Sum(backup)[0] / 255
                    pts.append((x, y, -total + next))
                    total = next

        #Fill in small regions
        for i in pts:
            if (i[2] < 100):
                cv.FloodFill(gray, (i[0], i[1]), (255,))

        #Find the minimum and maximum pixels
        min_left_up = (2 * width * height,)
        min_left_down = (2 * width * height,)
        min_right_up = (2 * width * height,)
        min_right_down = (2 * width * height,)
        for x in range(0, width):
            for y in range(0, height):
                if (cv.Get2D(gray, y, x)[0] < 10):
                    d = x * x + y * y
                    if (d < min_left_up[0]):
                        min_left_up = (d, x, y)
                    d = x * x + (height - y) * (height - y)
                    if (d < min_left_down[0]):
                        min_left_down = (d, x, y)
                    d = (width - x) * (width - x) + y * y
                    if (d < min_right_up[0]):
                        min_right_up = (d, x, y)
                    d = (width - x) * (width - x) + (height - y) * (height - y)
                    if (d < min_right_down[0]):
                        min_right_down = (d, x, y)

        print min_left_down
        print min_left_up
        print min_right_up
        print min_right_down

        if (len(min_left_down) != 3 or len(min_left_up) != 3
            or len(min_right_up) != 3 or len(min_right_down) != 3):
            print "Hosed floor"
            self.exit_floor = False
            return
    
        #Transform out the sign image
        transform = cv.CreateMat(3, 3, cv.CV_32F)
        cv.GetPerspectiveTransform(((min_left_down[1], min_left_down[2]),
                                    (min_right_down[1], min_right_down[2]),
                                    (min_right_up[1], min_right_up[2]),
                                    (min_left_up[1], min_left_up[2])),
                                   ((0, 100), (100, 100), (100, 0), (0, 0)), transform)
    
        sign_gray = cv.CreateImage((100, 100), 8, 1)
        cv.WarpPerspective(gray, sign_gray, transform)
        
        #sign_gray = cv.CreateImage(cv.GetSize(gray), 8, 1)
        #cv.CvtColor(sign, sign_gray, cv.CV_BGR2GRAY)
        #cv.EqualizeHist(sign_gray, sign_gray)
        #cv.Threshold(sign_gray, sign_gray, 220, 255, cv.CV_THRESH_BINARY)

        winner = None
        for i in self.floor_signs:
            delta = cv.CreateImage(cv.GetSize(sign_gray), 8, 1)
            cv.Copy(sign_gray, delta)
            cv.Sub(delta, self.floor_signs[i], delta)

            value = cv.Sum(delta)[0] / 255.0
            if (winner == None):
                winner = (i, value)
            elif (winner[1] > value):
                winner = (i, value)
        
        self.exit_floor = winner[0]
        print winner


        

    def process_lights(self, data):
        try:
            img = self.bridge.imgmsg_to_cv(data, "bgr8")
        except CvBridgeError, e:
            print e
        
        elevator_state = {}

        lights = self.lights #Avoid possible race condition
        for elevator in lights:
            elevator_state[elevator] = "off"
            for offset in [(0, 0), (-10, 0), (10, 0), (0, 10), (0, -10)]:
                up = 0.0
                down = 0.0
                if ("up" in lights[elevator]):
                    up = cv.Get2D(img, lights[elevator]["up"][1] + offset[1],
                                  lights[elevator]["up"][0]+ offset[0])[0]
                    cv.Circle(img, lights[elevator]["up"], 5, 200)
                if ("down" in lights[elevator]):
                    down = cv.Get2D(img, lights[elevator]["down"][1] + offset[1],
                                    lights[elevator]["down"][0] + offset[0])[0]
                    cv.Circle(img, lights[elevator]["down"], 5, 200)
                print up, down
                if (up > 250.0):
                    elevator_state[elevator] = "up"
                elif (down > 250.0):
                    elevator_state[elevator] = "down"
                
        self.elevator_state = elevator_state
                

    def image_callback(self, data):
        if (not self.process_im):
            return

        try:
            img = self.bridge.imgmsg_to_cv(data, "bgr8")
        except CvBridgeError, e:
          print e
  
        #text_font = cv.InitFont(cv2.CV_FONT_HERSHEY_DUPLEX, 2, 2)
        #cv.PutText(cv_image, "OpenCV Image", (50, height / 2), text_font, cv.RGB(255, 255, 0))
        

        gray = cv.CreateImage(cv.GetSize(img), 8, 1)
        edges = cv.CreateImage(cv.GetSize(img), 8, 1)
        cv.CvtColor(img, gray, cv.CV_BGR2GRAY)
        cv.Canny(gray, edges, 50, 100, 3)
        cv.Smooth(gray, gray, cv.CV_GAUSSIAN, 9, 9)

        storage = cv.CreateMat(30, 1, cv.CV_32FC3)

        cv.HoughCircles(edges, storage, cv.CV_HOUGH_GRADIENT, 2, 10.0, 250, 50,
                        min_radius=15, max_radius=30)

        found = 0
        avg_y = 0
        for i in range(0, storage.rows):
            dat = storage[i, 0]
            if (dat[0] > 150.0):
                if (self.cv_debug):
                    cv.Circle(edges, (dat[0], dat[1]), int(dat[2]), 200)
                avg_y = avg_y + dat[1]
                found = found + 1
        
        if (found > 0):
            avg_y = avg_y / found
            self.location = avg_y / edges.height - 0.5
        else:
            self.location = False
        
        """ Refresh the image on the screen """
        if (self.cv_debug):
            cv.ShowImage(self.cv_window_name, edges)
            cv.WaitKey(3)


    def extend_arm(self, root = 0.0, force = None):
        goal = JointTrajectory()
        goal.header.stamp = rospy.get_rostime()
        goal.joint_names = ["r_shoulder_pan_joint", "r_shoulder_lift_joint",
                            "r_upper_arm_roll_joint",
                            "r_elbow_flex_joint", "r_forearm_roll_joint",
                            "r_wrist_flex_joint", "r_wrist_roll_joint"]
        goal.points = [JointTrajectoryPoint()]
        if (force):
            goal.points[0].positions = force
        else:
            goal.points[0].positions = [root, 0.0, 0.0,
                                        -3.14159 / 180.0 * 50.0,
                                        3.14159, 0.0, 0.0]
        goal.points[0].velocities = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        goal.points[0].time_from_start = rospy.Duration.from_sec(3.0)

        self.arm.publish(goal)
        rospy.sleep(3.0)
            
    def set_depth(self, goal):
        while not rospy.is_shutdown():
            delta = self.get_vertical_depth(self.scan_msg) - goal
            if (delta > 0.2):
                delta = 0.2
            if (delta < -0.2):
                delta = -0.2
            if (delta < 0.01 and delta > -0.01):
                break
            tmsg = Twist()
            tmsg.linear.x = delta
            #print msg
            self.cmd_vel_publisher.publish(tmsg)

    def on_scan_msg(self, msg):
        self.scan_msg = msg

    def on_base_scan(self, msg):
        self.base_scan_msg = msg


    def wait_for_base_scan(self, clear = True):
        if (clear):
            self.base_scan_msg = False
        while not rospy.is_shutdown() and not self.base_scan_msg:
            rospy.sleep(0.01)

    def wait_for_scan(self, clear = True):
        if (clear):
            self.scan_msg = False
        while not rospy.is_shutdown() and not self.scan_msg:
            rospy.sleep(0.01)

    def set_laser_pos(self, pos):
        laser_per = SetPeriodicCmdRequest()
        laser_per.command.header.stamp = rospy.Time.now()
        laser_per.command.profile = "linear"
        laser_per.command.period = 1
        laser_per.command.amplitude = 0
        laser_per.command.offset = pos
        junk = self.set_laser(laser_per)

    def set_laser_and_wait(self, pos):
        self.set_laser_pos(pos)
        rospy.sleep(2.0)
        self.wait_for_scan()

    def hand_dist(self, pos1):
        dist = 0.0
        for axis in zip(pos1, self.get_end_effector_pos()):
            delta = axis[0] - axis[1]
            dist = dist + (delta * delta)
        dist = math.sqrt(dist)
        return dist

    def set_gripper(self, pos):
        grip = Pr2GripperCommandGoal()
        grip.command.position = pos
        grip.command.max_effort = 10000
        #print grip
        self.gripper.send_goal(grip)
        self.gripper.wait_for_result()

    def tuck_arms(self, wait=True):
        tuck_goal = TuckArmsGoal()
        tuck_goal.tuck_left = True
        tuck_goal.tuck_right = True
        self.tuck.send_goal(tuck_goal)
        if (wait):
            self.tuck.wait_for_result()

        
    def get_end_effector_pos(self):
        self.listener.waitForTransform("/r_wrist_roll_link", "/base_link",
                                       rospy.Time(), rospy.Duration(30))
        target, rot = self.listener.lookupTransform("/base_link",
                                                    "/r_wrist_roll_link", 
                                                    rospy.Time())
        rot = False
        return target


    def arm_move(self, x, y, z, duration=3, wait=True):
        response = self.query_client(GetKinematicSolverInfoRequest())
        if (not response):
            print "Failed - no info:", x, y, z
            return False
        
        kin = GetPositionIKRequest()
        kin.timeout = rospy.Duration(5.0)
        kin.ik_request.ik_link_name = "r_wrist_roll_link"
        kin.ik_request.pose_stamped.header.frame_id = "base_link"
        kin.ik_request.pose_stamped.pose.position.x = x
        kin.ik_request.pose_stamped.pose.position.y = y
        kin.ik_request.pose_stamped.pose.position.z = z
        kin.ik_request.pose_stamped.pose.orientation.x = 0.0
        kin.ik_request.pose_stamped.pose.orientation.y = 0.0
        kin.ik_request.pose_stamped.pose.orientation.z = 0.0
        kin.ik_request.pose_stamped.pose.orientation.w = 1.0
        kin.ik_request.ik_seed_state.joint_state.name \
            = response.kinematic_solver_info.joint_names
        for i in range(0, len(response.kinematic_solver_info.joint_names)):
            minp = response.kinematic_solver_info.limits[i].min_position 
            maxp = response.kinematic_solver_info.limits[i].max_position
            while (len(kin.ik_request.ik_seed_state.joint_state.position) <= i):
                kin.ik_request.ik_seed_state.joint_state.position += [0.0]
            kin.ik_request.ik_seed_state.joint_state.position[i] \
                = (minp + maxp) / 2.0
        
        resp = self.ik_client(kin)
        if (not resp):
            #FIXME
            print "Failed - no response:", x, y, z
            return False

        if (len(resp.solution.joint_state.position) 
            != len(kin.ik_request.ik_seed_state.joint_state.name)):
            print "Failed - no data:", x, y, z
            return False
        
        goal = JointTrajectory()
        goal.header.stamp = rospy.get_rostime()
        goal.joint_names = kin.ik_request.ik_seed_state.joint_state.name
        goal.points = [JointTrajectoryPoint()]
        goal.points[0].positions = resp.solution.joint_state.position
        goal.points[0].velocities = map(lambda (x): 0.0, \
                                            resp.solution.joint_state.position)
        goal.points[0].time_from_start = rospy.Duration.from_sec(duration)

        self.arm.publish(goal)
        if (wait):
            rospy.sleep(duration)
        
        return True
        
        

        
    def line_up(self, msg):
        xy = self.scan_to_points(msg)
        xy_c = []
        for i in xy:
            if (i[1] > -0.25 and i[1] < 0.25 and i[0] > 0.05):
                xy_c.append(i)

        marker = Marker()
        marker.header.frame_id = msg.header.frame_id
        marker.header.stamp = rospy.get_rostime()
        marker.ns = "elevator_blast"
        marker.type = Marker.CUBE
        marker.action = Marker.MODIFY
        marker.id = 0
        marker.pose.position.x = 1.2
        marker.pose.position.y = 0
        marker.pose.position.z = 0.5
        marker.pose.orientation.x = 0.0
        marker.pose.orientation.y = 0.0
        marker.pose.orientation.z = 0.0
        marker.pose.orientation.w = 1.0
        marker.scale.x = 0.5
        marker.scale.y = 1.0
        marker.scale.z = 1
        marker.color.a = 0.1
        marker.color.r = 0.0
        marker.color.g = 0.0
        marker.color.b = 1.0
        self.visualization_publisher.publish(marker)

        #print xy_c
        n = len(xy_c)
        Sx = Sy = Sxx = Syy = Sxy = 0.0
        for pt in xy_c:
            x = pt[1]
            y = pt[0]
            Sx = Sx + x
            Sy = Sy + y
            Sxx = Sxx + x*x
            Syy = Syy + y*y
            Sxy = Sxy + x*y
        det = Sxx * n - Sx * Sx
        a, b = (Sxy * n - Sy * Sx)/det, (Sxx * Sy - Sx * Sxy)/det
        meanerror = residual = 0.0
        for pt in xy_c:
            x = pt[1]
            y = pt[0]
            meanerror = meanerror + (y - Sy/n)**2
            residual = residual + (y - a * x - b)**2
        RR = 1 - residual/meanerror
        ss = residual / (n-2)
        print a, b, RR
        
        #a = a - 0.12 #FIXME: param for offset

        msg = Twist()
        speed_lim = 0.15 #FIXME param
        scal = 4.0
        if (-a * scal > speed_lim):
            msg.angular.z = speed_lim
        elif (-a * scal < -speed_lim):
            msg.angular.z = -speed_lim
        else:
            msg.angular.z = -a * scal

        print "Line up"
        print msg
        self.cmd_vel_publisher.publish(msg)
        
        tol = 0.005 #FIXME: param

        if (a < tol and a > -tol):
            return a
        return False
        

    def scan_to_points(self, msg):
        xy = []
        angle = msg.angle_min
        for r in range(0, len(msg.ranges)):
            dist = msg.ranges[r]
            xy.append([dist * math.cos(angle), dist * math.sin(angle)])
            angle = angle + msg.angle_increment
        return xy


    def check_square(self, msg):
        pts = self.scan_to_points(msg)
    
        front_wall = pts[0]
        for i in pts:
            if (i[0] > 0.0 and abs(i[1]) < abs(front_wall[1])):
                front_wall = i
        left_wall = pts[0]
        for i in pts:
            if (i[1] < 0.0 and abs(i[0]) < abs(left_wall[0])):
                left_wall = i
        right_wall = pts[0]
        for i in pts:
            if (i[1] > 0.0 and abs(i[0]) < abs(right_wall[0])):
                right_wall = i
        
        w = 0.20
        
        self.cube(msg.header.frame_id, front_wall[0], 
                  0.0, 0.0, w * 2, 0.5, 6.0, 0)
        self.cube(msg.header.frame_id, 0.0, left_wall[1], 
                  0.0, 6.0, 0.5, w * 2, 1)
        self.cube(msg.header.frame_id, 0.0, right_wall[1], 
                  0.0, 6.0, 0.5, w * 2, 2)
        print msg
        print front_wall[0], left_wall[1], right_wall[1]
        for i in pts:
            if (i[0] < 0.0):
                continue
            if (i[0] > front_wall[0] - w and i[0] < front_wall[0] + w):
                continue
            if (i[1] > left_wall[1] - w and i[1] < left_wall[1] + w):
                continue
            if (i[1] > right_wall[1] - w and i[1] < right_wall[1] + w):
                continue
            return False
        return True
        
    def get_vertical_depth(self, msg):
        marker = Marker()
        marker.header.frame_id = msg.header.frame_id
        marker.header.stamp = rospy.get_rostime()
        marker.ns = "elevator_blast"
        marker.type = Marker.CYLINDER
        marker.action = Marker.MODIFY
        marker.id = 0
        marker.pose.position.x = 0
        marker.pose.position.y = 0
        marker.pose.position.z = 0.5
        marker.pose.orientation.x = 0.0
        marker.pose.orientation.y = 0.0
        marker.pose.orientation.z = 0.0
        marker.pose.orientation.w = 1.0
        marker.scale.x = 0.5
        marker.scale.y = 0.5
        marker.scale.z = 1
        marker.color.a = 1.0
        marker.color.r = 0.0
        marker.color.g = 0.0
        marker.color.b = 1.0
        self.visualization_publisher.publish(marker)
        
        xy = self.scan_to_points(msg)
    
        #Find the distance to the wall
        min_door = False
        for pt in xy:
            if (pt[1] < 0.75 and pt[1] > -0.75 and pt[0] > 0.01):
                if (min_door == False or min_door > pt[0]):
                    min_door = pt[0]
                
        marker = Marker()
        marker.header.frame_id = msg.header.frame_id
        marker.header.stamp = rospy.get_rostime()
        marker.ns = "elevator_blast"
        marker.type = Marker.CUBE
        marker.action = Marker.MODIFY
        marker.id = 1
        marker.pose.position.x = min_door
        marker.pose.position.y = 0
        marker.pose.position.z = 0.5
        marker.pose.orientation.x = 0.0
        marker.pose.orientation.y = 0.0
        marker.pose.orientation.z = 0.0
        marker.pose.orientation.w = 1.0
        marker.scale.x = 2.0
        marker.scale.y = 2.0
        marker.scale.z = 1
        marker.color.a = 0.4
        marker.color.r = 0.0
        marker.color.g = 0.0
        marker.color.b = 1.0
        self.visualization_publisher.publish(marker)

        goal = PoseStamped()
        goal.header.frame_id = msg.header.frame_id
        dist = min_door
        goal.pose.position.x = min_door
        #print goal
        goal = self.listener.transformPose("/base_link", goal)
        #print goal
        return goal.pose.position.x

    def delete_markers(self, frame_id, lim):
        for n in range(0, lim):
            marker = Marker()
            marker.header.frame_id = frame_id
            marker.header.stamp = rospy.get_rostime()
            marker.ns = "elevator_blast"
            marker.type = Marker.CYLINDER
            marker.action = Marker.DELETE
            marker.id = n
            self.visualization_publisher.publish(marker)

    def generate_goal(self, dist, angle, xy = False):
        base_frame = "/base_footprint"
        odom_frame = "/odom_combined" #FIXME param
        
        while not rospy.is_shutdown(): #FIXME
            try:
                self.listener.waitForTransform(base_frame, odom_frame,
                                               rospy.Time(), rospy.Duration(30))
                
                goal = PoseStamped()
                goal.header.frame_id = base_frame
                if (xy):
                    goal.pose.position.x = dist
                    goal.pose.position.y = angle
                else:
                    goal.pose.position.x = dist * math.cos(angle)
                    goal.pose.position.y = dist * math.sin(angle)
                goal = self.listener.transformPose(odom_frame, goal)
                #print goal
                break
            except (tf.LookupException, tf.ConnectivityException,
                    tf.ExtrapolationException) as ex:
                rospy.logwarn("TF error") #FIXME: warning
        
        return goal

    def move_to_target(self, goal, angle_offset, no_y_reset=False, 
                       extreme_turn=False, watch_scans=False):
        base_frame = "/base_footprint" #FIXME: param
        
        rate = rospy.Rate(10)
        reset = False
        while not rospy.is_shutdown(): #FIXME
            try:
                goal_transformed = self.listener.transformPose(base_frame, goal)
                
                #print goal_transformed
                
                def scaleclamp(val, scale, lim, min_v = 0):
                    t = val * scale
                    if (t > lim):
                        return lim
                    if (t < -lim):
                        return -lim
                    if (t < min_v and t > -min_v):
                        if (t < 0):
                            t = -min_v
                        if (t > 0):
                            t = min_v
                    return t
                
                msg = Twist()
                p, r, y = tf.transformations.euler_from_quaternion(
                    (goal_transformed.pose.orientation.x,
                     goal_transformed.pose.orientation.y,
                     goal_transformed.pose.orientation.z,
                     goal_transformed.pose.orientation.w))
                msg.angular.x = 0
                msg.angular.y = 0
                if (reset):
                    msg.angular.z = scaleclamp(y, 1, 0.5, 0.005)
                    if (y > -0.05 and y < 0.05 or no_y_reset):
                        break
                else:
                    w = y + angle_offset
                    print y, angle_offset, w

                    dist = goal_transformed.pose.position.y \
                        * goal_transformed.pose.position.y
                    dist = dist + goal_transformed.pose.position.x \
                        * goal_transformed.pose.position.x
                    dist = math.sqrt(dist)
                    #print dist

                    #if (dist > 1.6):
                    #    w = w - (math.pi / 8)

                    while (w > math.pi):
                        w = w - math.pi * 2.0
                    while (w < -math.pi):
                        w = w + math.pi * 2.0

                    scale = 1.5
                    if (extreme_turn):
                        scale = 3.0

                    min_value = 0.05
                    if (w < 0.01 and w > -0.01):
                        min_value = 0
                    msg.angular.z = scaleclamp(w, scale, 0.8, min_value)
                
                    if (w > -0.15 and w < 0.15):
                        if (dist < 0.03): #Fixme
                            if (w > -0.01 and w < 0.01 or not no_y_reset):
                                reset = True

                        dist = scaleclamp(dist, 1.0, 1.0)
                        ang = math.atan2(goal_transformed.pose.position.y,
                                         goal_transformed.pose.position.x)
                        msg.linear.x = dist * math.cos(ang)
                        msg.linear.y = dist * math.sin(ang)
                    

                    if (watch_scans != False):
                        pts = self.scan_to_points(self.base_scan_msg)
                        blocked = False
                        if (msg.linear.y < -0.03):
                            for i in pts:
                                if (i[0] < 0.00 and i[0] > -0.50 \
                                        and i[1] > -1.0 and i[1] < -0.30):
                                    blocked = True
                        if (msg.linear.y > 0.03):
                            for i in pts:
                                if (i[0] < 0.00 and i[0] > -0.50 \
                                        and i[1] < 1.0 and i[1] > 0.30):
                                    blocked = True
                        if (msg.linear.x > 0.03):
                            for i in pts:
                                if (i[0] < 0.70 and i[0] > 0.00 \
                                        and i[1] < 0.25 and i[1] > -0.25):
                                    blocked = True

                        if (blocked):
                            rate.sleep()
                            msg.linear.x = 0
                            msg.linear.y = 0
                            msg.angular.z = 0
                            if (watch_scans == "BAIL"):
                                self.cmd_vel_publisher.publish(msg)
                                print "Bail"
                                return False




                #print "go forward", msg
                
                self.cmd_vel_publisher.publish(msg)
                
                rate.sleep()
            except (tf.LookupException, tf.ConnectivityException,
                    tf.ExtrapolationException) as ex:
                rospy.logwarn("TF error") #FIXME
        return True
                

if __name__ == '__main__':
    rospy.init_node("elevator_blast")
    blast = ElevatorControl()
    rospy.spin()
    
